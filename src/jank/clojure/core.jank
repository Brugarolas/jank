; The layout of this file roughly matches: https://clojure.org/api/cheatsheet

; Namespace management.
(def *ns*)
(def in-ns)

; Exceptions
(def ex-info
  (fn* [msg map]
    {:error msg
     :data map}))

; Relations.
;; Miscellaneous.
(def nil?
  (fn* [o]
    (native/raw "__value = (o == obj::nil::nil_const()) ? #{ true }# : #{ false }#")))

;; Collections.
(def empty?
  (fn* [o]
    (if (nil? o)
      true
      (native/raw "__value = visit_object
                  (
                   [=](auto const typed_o) -> obj::boolean_ptr
                   {
                    using T = typename decltype(typed_o)::value_type;

                    if constexpr(behavior::seqable<T>)
                    { return make_box(typed_o->seq() == nullptr); }
                    else
                    { throw #{ (ex-info :not-seqable {:o o}) }#; }
                    },
                   #{ o }#
                   );"))))

(def count
  (fn* [o]
    (if (nil? o)
      0
      (native/raw "__value = make_box(runtime::detail::sequence_length(#{ o }#));"))))

; Lists.
; TODO: Can these be removed from the C++ source?
;(def seq
;  (fn* seq [o]
;    (native/raw "__value = visit_object
;                 (
;                   [=](auto const typed_o) -> object_ptr
;                   {
;                     using T = typename decltype(typed_o)::value_type;
;
;                     if constexpr(std::same_as<T, obj::nil>)
;                     { return typed_o; }
;                     else if constexpr(behavior::seqable<T>)
;                     {
;                       auto const &ret(typed_o->seq());
;                       if(!ret)
;                       { return obj::nil::nil_const(); }
;
;                       return ret;
;                     }
;                     else
;                     { throw #{ (ex-info :not-seqable {:o o}) }#; }
;                   },
;                   #{ o }#
;                 );")))
;(def fresh-seq
;  (fn* fresh-seq [o]
;    (native/raw "__value = visit_object
;                 (
;                   [=](auto const typed_o) -> object_ptr
;                   {
;                     using T = typename decltype(typed_o)::value_type;
;
;                     if constexpr(std::same_as<T, obj::nil>)
;                     { return typed_o; }
;                     else if constexpr(behavior::seqable<T>)
;                     {
;                       auto const &ret(typed_o->seq());
;                       if(!ret)
;                       { return obj::nil::nil_const(); }
;
;                       return ret;
;                     }
;                     else
;                     { throw #{ (ex-info :not-seqable {:o o}) }#; }
;                   },
;                   #{ o }#
;                 );")))
(def first
  (fn* first [o]
    (native/raw "__value = jank::runtime::first(#{ o }#);")))
(def next
  (fn* next [o]
    (native/raw "__value = jank::runtime::next(#{ o }#);")))
(def next-in-place
  (fn* next-in-place [o]
    (native/raw "__value = jank::runtime::next_in_place(#{ o }#);")))
(def nnext
  (fn* nnext [o]
    (next-in-place (next o))))
(def second
  (fn* second [o]
    (first (next o))))
(def rest
  (fn* rest [o]
    (if (nil? o)
      '()
      (native/raw "__value = visit_object
                   (
                     [=](auto const typed_o) -> object_ptr
                     {
                       using T = typename decltype(typed_o)::value_type;

                       if constexpr(behavior::seqable<T>)
                       {
                         auto const seq(typed_o->seq());
                         if(!seq)
                         { return #{ '() }#; }
                         auto const ret(seq->next());
                         if(ret == nullptr)
                         { return #{ '() }#; }
                         return ret;
                       }
                       else
                       { throw #{ (ex-info :not-seqable {:o o}) }#; }
                     },
                     #{ o }#
                   );"))))
(def cons
  (fn* cons [head tail]
    (native/raw "__value = visit_object
                 (
                   [=](auto const typed_tail) -> object_ptr
                   {
                     using T = typename decltype(typed_tail)::value_type;

                     if constexpr(behavior::seqable<T>)
                     { return make_box<jank::runtime::obj::cons>(#{ head }#, typed_tail->seq()); }
                     else
                     { throw #{ (ex-info :invalid-cons-tail {:head head :tail tail}) }#; }
                   },
                   #{ tail }#
                 );")))
(def list
  (fn* list [& items]
    (native/raw "__value = visit_object
                 (
                   [=](auto const typed_items) -> object_ptr
                   {
                     using T = typename decltype(typed_items)::value_type;

                     if constexpr(behavior::seqable<T>)
                     { return jank::runtime::obj::list::create(typed_items); }
                     else
                     { throw #{ (ex-info :invalid-seq {:items items}) }#; }
                   },
                   #{ items }#
                 );")))

;; Vectors.
(def vec
  (fn* vec [coll]
    (native/raw "__value = visit_object
                 (
                   [=](auto const typed_coll) -> object_ptr
                   {
                     using T = typename decltype(typed_coll)::value_type;

                     if constexpr(behavior::seqable<T>)
                     { return jank::runtime::obj::vector::create(typed_coll); }
                     else
                     { throw #{ (ex-info :invalid-seq {:coll coll}) }#; }
                   },
                   #{ coll }#
                 );")))

(def conj)
(def conj
  (fn*
    conj ([]
     [])
    ([coll]
     coll)
    ([coll x]
     (native/raw "__value = jank::runtime::conj(#{ coll }#, #{ x }#);"))
    ([coll x & args]
     (let* [res (conj coll x)]
       (if (empty? args)
         res
         (recur res (first args) (next args)))))))

;; Metadata
(def meta
  (fn* meta [o]
    (native/raw "__value = visit_object
                 (
                   [=](auto const typed_o) -> object_ptr
                   {
                     using T = typename decltype(typed_o)::value_type;

                     if constexpr(behavior::metadatable<T>)
                     {
                       if(typed_o->meta.is_none())
                       { return #{ nil }#; }
                       return typed_o->meta.unwrap();
                     }
                     else
                     { return #{ nil }#; }
                   },
                   #{ o }#
                 );")))
(def with-meta
  (fn* with-meta [o m]
    (native/raw "__value = visit_object
                 (
                   [=](auto const typed_o) -> object_ptr
                   {
                     using T = typename decltype(typed_o)::value_type;

                     if constexpr(behavior::metadatable<T>)
                     { return typed_o->with_meta(#{ m }#); }
                     else
                     { throw #{ (ex-info :not-metadatable {:o o}) }#; }
                   },
                   #{ o }#
                 );")))
(def reset-meta!
  (fn* reset-meta! [o m]
    (native/raw "__value = visit_object
                 (
                   [=](auto const typed_o) -> object_ptr
                   {
                     using T = typename decltype(typed_o)::value_type;

                     if constexpr(behavior::metadatable<T>)
                     {
                       auto const meta(behavior::detail::validate_meta(#{ m }#));
                       typed_o->meta = meta;
                       return #{ m }#;
                     }
                     else
                     { throw #{ (ex-info :not-metadatable {:o o}) }#; }
                   },
                   #{ o }#
                 );")))

;; Macros.
(def defn
  (fn* defn [&form &env fn-name fn-args & body]
    (list 'do
          ; TODO: Remove this once fn* supports naming.
          (list 'def fn-name)
          (list 'def fn-name (cons 'fn* (cons fn-name (cons fn-args body)))))))
(reset-meta! (var defn) {:macro true})

(defn defmacro [&form &env fn-name fn-args & body]
  (list 'do
        (list 'def fn-name (cons 'fn* (cons (vec (cons '&form (cons '&env fn-args))) body)))
        (list 'reset-meta! (list 'var fn-name) {:macro true})))
(reset-meta! (var defmacro) {:macro true})

(defmacro when [condition & body]
  (list 'if condition
        (cons 'do body)
        nil))

(defmacro fn [args & body]
  (cons 'fn* (cons args body)))

(defmacro let [args & body]
  (cons 'let* (cons args body)))

(defn macroexpand-1 [form]
  (native/raw "__value = __rt_ctx.macroexpand1(#{ form }#);"))
(defn macroexpand [form]
  (native/raw "__value = __rt_ctx.macroexpand(#{ form }#);"))

; Relations.
;; Miscellaneous.
(defn true? [o]
  (native/raw "__value = runtime::detail::equal(#{ o }#, #{ true }#) ? #{ true }# : #{ false }#"))
(defn false? [o]
  (native/raw "__value = runtime::detail::equal(#{ o }#, #{ false }#) ? #{ true }# : #{ false }#"))
(defn not [o]
  (native/raw "__value = runtime::detail::equal(#{ o }#, #{ false }#) ? #{ true }# : #{ false }#"))
(defn some? [o]
  (native/raw "__value = (o == obj::nil::nil_const()) ? #{ false }# : #{ true }#"))

; Strings.
(defn string? [o]
  (native/raw "__value = make_box(#{ o }#->type == object_type::string);"))
(defn str
  ([]
   "")
  ([o]
   (native/raw "__value = make_box(runtime::detail::to_string(#{ o }#));"))
  ([o & args]
   (native/raw "__value = visit_object
               (
                [=](auto const typed_args) -> object_ptr
                {
                 using T = typename decltype(typed_args)::value_type;

                 if constexpr(behavior::sequenceable<T>)
                 {
                  fmt::memory_buffer buff;
                  buff.reserve(16);
                  runtime::detail::to_string(#{ o }#, buff);
                  runtime::detail::to_string(typed_args->first(), buff);
                  for(auto it(typed_args->next_in_place()); it != nullptr; it = it->next_in_place())
                  { runtime::detail::to_string(typed_args->first(), buff); }
                  return make_box<obj::string>(native_string{ buff.data(), buff.size() });
                  }
                 else
                 { throw #{ (ex-info :invalid-seq {:args args}) }#; }
                 },
                #{ args }#
                );")))

;; Maps.
(defn get
  ([m k]
   (native/raw "__value = jank::runtime::get(#{ m }#, #{ k }#);"))
  ([m k fallback]
   (native/raw "__value = jank::runtime::get(#{ m }#, #{ k }#, #{ fallback }#);")))
(defn get-in
  ([m ks]
   (native/raw "__value = jank::runtime::get_in(#{ m }#, #{ ks }#);"))
  ([m ks fallback]
   (native/raw "__value = jank::runtime::get_in(#{ m }#, #{ ks }#, #{ fallback }#);")))

;; Other.
(defn hash [o]
  (native/raw "__value = make_box(runtime::detail::to_hash(#{ o }#));"))

(defn assoc
  ([map key val]
   (native/raw "__value = jank::runtime::assoc(#{ map }#, #{ key }#, #{ val }#);"))
  ([map key val & kvs]
   (let [res (assoc map key val)]
     (if (empty? kvs)
       res
       (do
         (assert (not (empty? (next kvs)))); "assoc expects even number of args after the first"
         (recur res (first kvs) (second kvs) (nnext kvs)))))))

(defn reduce*
  ([f coll]
   (let [s (seq coll)]
     (if s
       (reduce* f (first s) (next s))
       (f))))
  ([f val coll]
   (native/raw "__value = visit_object
               (
                [=](auto const typed_coll) -> object_ptr
                {
                 using T = typename decltype(typed_coll)::value_type;

                 if constexpr(behavior::seqable<T>)
                 {
                  object_ptr res{ #{ val }# };
                  for(auto it(typed_coll->fresh_seq()); it != nullptr; it = it->next_in_place())
                  { res = dynamic_call(#{ f }#, res, it->first()); }
                  return res;
                  }
                 else
                 { throw #{ (ex-info :invalid-seq {:coll coll}) }#; }
                 },
                #{ coll }#
                );")))

(defn reverse [coll]
  (reduce* conj () coll))

; Primitives.
;; Arithmetic.
(defn +
  ([]
   0)
  ([x]
   x)
  ([l r]
   (native/raw "__value = add(#{ l }#, #{ r }#);"))
  ([l r & args]
   (let [res (native/raw "__value = add(#{ l }#, #{ r }#);")]
     (if (empty? args)
       res
       (recur res (first args) (next args))))))
(reset-meta! (var +) {:arities {2 {:supports-unboxed-input? true
                                   :unboxed-output? true}}})

(defn -
  ([x]
   (- 0 x))
  ([l r]
   (native/raw "__value = sub(#{ l }#, #{ r }#);"))
  ([l r & args]
   (let [res (native/raw "__value = sub(#{ l }#, #{ r }#);")]
     (if (empty? args)
       res
       (recur res (first args) (next args))))))
(reset-meta! (var -) {:arities {2 {:supports-unboxed-input? true
                                   :unboxed-output? true}}})

(defn *
  ([]
   1)
  ([x]
   x)
  ([l r]
   (native/raw "__value = mul(#{ l }#, #{ r }#);"))
  ([l r & args]
   (let [res (native/raw "__value = mul(#{ l }#, #{ r }#);")]
     (if (empty? args)
       res
       (recur res (first args) (next args))))))
(reset-meta! (var *) {:arities {2 {:supports-unboxed-input? true
                                   :unboxed-output? true}}})

; TODO: Symbol creation for generated names related to instances of this
; will result in a name like `/384`, which gets parsed as `384`. Fix the parsing
; in the symbol string separation fn.
(def /)
(def /
  (fn _SLASH_
    ([x]
     (/ 1 x))
    ([l r]
     (native/raw "__value = div(#{ l }#, #{ r }#);"))
    ([l r & args]
     (let [res (native/raw "__value = div(#{ l }#, #{ r }#);")]
       (if (empty? args)
         res
         (recur res (first args) (next args)))))))
(reset-meta! (var /) {:arities {2 {:supports-unboxed-input? true
                                   :unboxed-output? true}}})

(defn =
  ([x]
   true)
  ([l r]
   (native/raw "__value = make_box(runtime::detail::equal(#{ l }#, #{ r }#));"))
  ([l r & args]
   (if (native/raw "__value = make_box(runtime::detail::equal(#{ l }#, #{ r }#));")
     (if (next args)
       (recur r (first args) (next args))
       (native/raw "__value = make_box(runtime::detail::equal(#{ r }#, #{ (first args) }#));"))
     false)))

(defn <
  ([x]
   true)
  ([l r]
   (native/raw "__value = make_box(lt(#{ l }#, #{ r }#));"))
  ([l r & args]
   (if (native/raw "__value = make_box(lt(#{ l }#, #{ r }#));")
     (if (next args)
       (recur r (first args) (next args))
       (native/raw "__value = make_box(lt(#{ r }#, #{ (first args) }#));"))
     false)))
(reset-meta! (var <) {:arities {2 {:supports-unboxed-input? true
                                   :unboxed-output? true}}})

(defn <=
  ([x]
   true)
  ([l r]
   (native/raw "__value = make_box(lte(#{ l }#, #{ r }#));"))
  ([l r & args]
   (if (native/raw "__value = make_box(lte(#{ l }#, #{ r }#));")
     (if (next args)
       (recur r (first args) (next args))
       (native/raw "__value = make_box(lte(#{ r }#, #{ (first args) }#));"))
     false)))
(reset-meta! (var <=) {:arities {2 {:supports-unboxed-input? true
                                    :unboxed-output? true}}})

(defn >
  ([x]
   true)
  ([l r]
   (native/raw "__value = make_box(lt(#{ r }#, #{ l }#));"))
  ([l r & args]
   (if (native/raw "__value = make_box(lt(#{ r }#, #{ l }#));")
     (if (next args)
       (recur r (first args) (next args))
       (native/raw "__value = make_box(lt(#{ (first args) }#, #{ r }#));"))
     false)))
(reset-meta! (var >) {:arities {2 {:supports-unboxed-input? true
                                   :unboxed-output? true}}})

(defn >=
  ([x]
   true)
  ([l r]
   (native/raw "__value = make_box(lte(#{ r }#, #{ l }#));"))
  ([l r & args]
   (if (native/raw "__value = make_box(lte(#{ r }#, #{ l }#));")
     (if (next args)
       (recur r (first args) (next args))
       (native/raw "__value = make_box(lte(#{ (first args) }#, #{ r }#));"))
     false)))
(reset-meta! (var >=) {:arities {2 {:supports-unboxed-input? true
                                    :unboxed-output? true}}})

(defn min
  ([x]
   x)
  ([l r]
   (native/raw "__value = min(#{ l }#, #{ r }#);"))
  ([l r & args]
   (let [res (native/raw "__value = min(#{ l }#, #{ r }#);")]
     (if (empty? args)
       res
       (recur res (first args) (next args))))))
(reset-meta! (var min) {:arities {2 {:supports-unboxed-input? true
                                     :unboxed-output? true}}})

(defn max
  ([x]
   x)
  ([l r]
   (native/raw "__value = max(#{ l }#, #{ r }#);"))
  ([l r & args]
   (let [res (native/raw "__value = max(#{ l }#, #{ r }#);")]
     (if (empty? args)
       res
       (recur res (first args) (next args))))))
(reset-meta! (var max) {:arities {2 {:supports-unboxed-input? true
                                     :unboxed-output? true}}})

(defn inc [n]
  (native/raw "__value = inc(#{ n }#);"))
(defn dec [n]
  (native/raw "__value = dec(#{ n }#);"))

(defn pos? [n]
  (native/raw "__value = make_box(is_pos(#{ n }#));"))
(defn neg? [n]
  (native/raw "__value = make_box(is_neg(#{ n }#));"))
(defn zero? [n]
  (native/raw "__value = make_box(is_zero(#{ n }#));"))

(defn rem [num div]
  (native/raw "__value = rem(#{ num }#, #{ div }#);"))
(defn mod [num div]
  (let [m (rem num div)]
    ; TODO: Could use an or here, if we had it.
    (if (zero? m)
      m
      (if (= (pos? num) (pos? div))
        m
        (+ m div)))))

;; Numbers.
(defn integer? [o]
  (native/raw "__value = make_box(#{ o }#->type == object_type::integer)"))
(defn float? [o]
  (native/raw "__value = make_box(#{ o }#->type == object_type::real)"))
(defn boolean? [o]
  (native/raw "__value = make_box(#{ o }#->type == object_type::boolean)"))
(defn number? [o]
  (native/raw "__value = make_box
              (
               visit_object
               (
                [=](auto const typed_o) -> native_bool
                {
                 using T = typename decltype(typed_o)::value_type;

                 if constexpr(behavior::numberable<T>)
                 { return true; }
                 else
                 { return false; }
                 },
                #{ o }#
                )
               );"))

(defn int [o]
  (native/raw "__value = make_box(to_int(#{ o }#));"))
(defn float [o]
  (native/raw "__value = make_box
              (
               visit_object
               (
                [=](auto const typed_o) -> native_real
                {
                 using T = typename decltype(typed_o)::value_type;

                 if constexpr(behavior::numberable<T>)
                 { return typed_o->to_real(); }
                 else
                 { throw #{ (ex-info :not-a-number {:o o}) }#; }
                 },
                #{ o }#
                )
               );"))

(defn even? [o]
  (native/raw "__value = make_box
              (
               visit_object
               (
                [=](auto const typed_o) -> native_bool
                {
                 using T = typename decltype(typed_o)::value_type;

                 if constexpr(std::is_same_v<T, obj::integer>)
                 { return typed_o->data % 2 == 0; }
                 else
                 { throw #{ (ex-info :not-an-integer {:o o}) }#; }
                 },
                #{ o }#
                )
               );"))
(defn odd? [o]
  (native/raw "__value = make_box
              (
               visit_object
               (
                [=](auto const typed_o) -> native_bool
                {
                 using T = typename decltype(typed_o)::value_type;

                 if constexpr(std::is_same_v<T, obj::integer>)
                 { return typed_o->data % 2 == 1; }
                 else
                 { throw #{ (ex-info :not-an-integer {:o o}) }#; }
                 },
                #{ o }#
                )
               );"))

;; Random.
(defn rand
  ([]
   (native/raw "__value = make_box(jank::runtime::rand());"))
  ([n]
   (* (rand) n)))

;; Keywords.
(defn keyword? [o]
  (native/raw "__value = make_box(#{ o }#->type == object_type::keyword)"))
(defn simple-keyword? [o]
  (native/raw "__value = make_box
              (
               visit_object
               (
                [=](auto const typed_o) -> native_bool
                {
                 using T = typename decltype(typed_o)::value_type;

                 if constexpr(std::is_same_v<T, obj::keyword>)
                 { return typed_o->sym.ns.empty(); }
                 else
                 { return false; }
                 },
                #{ o }#
                )
               );"))
(defn qualified-keyword? [o]
  (native/raw "__value = make_box
              (
               visit_object
               (
                [=](auto const typed_o) -> native_bool
                {
                 using T = typename decltype(typed_o)::value_type;

                 if constexpr(std::is_same_v<T, obj::keyword>)
                 { return !typed_o->sym.ns.empty(); }
                 else
                 { return false; }
                 },
                #{ o }#
                )
               );"))
(defn simple-symbol? [o]
  (native/raw "__value = make_box
              (
               visit_object
               (
                [=](auto const typed_o) -> native_bool
                {
                 using T = typename decltype(typed_o)::value_type;

                 if constexpr(std::is_same_v<T, obj::symbol>)
                 { return typed_o->ns.empty(); }
                 else
                 { return false; }
                 },
                #{ o }#
                )
               );"))
(defn qualified-symbol? [o]
  (native/raw "__value = make_box
              (
               visit_object
               (
                [=](auto const typed_o) -> native_bool
                {
                 using T = typename decltype(typed_o)::value_type;

                 if constexpr(std::is_same_v<T, obj::symbol>)
                 { return !typed_o->ns.empty(); }
                 else
                 { return false; }
                 },
                #{ o }#
                )
               );"))
(defn symbol? [o]
  (native/raw "__value = make_box(#{ o }#->type == object_type::symbol)"))

;; Sequences.

(defn iterate [f x]
  (native/raw "__value = visit_object
              (
               [=](auto const typed_f) -> object_ptr
               {
                using T = typename decltype(typed_f)::value_type;

                if constexpr(std::is_base_of_v<behavior::callable, T>)
                { return make_box<obj::iterator>(typed_f, #{ x }#); }
                else
                { throw #{ (ex-info :not-callable {:f f}) }#; }
                },
               #{ f }#
               );"))

(defn range
  ([]
   (iterate inc 0))
  ([end]
   (native/raw "__value = make_box<obj::range>(#{ end }#);"))
  ([start end]
   (native/raw "__value = make_box<obj::range>(#{ start }#, #{ end }#);"))
  ([start end step]
   (native/raw "__value = make_box<obj::range>(#{ start }#, #{ end }#, #{ step }#);")))

(defn take
  ; TODO: Transducer.
  ([n]
   )
  ([n coll]
   ; TODO: Lazy version once we have lazy-seq.
   (let [take* (fn* take* [n coll acc]
                 (if (zero? n)
                   acc
                   (if (empty? coll)
                     acc
                     (recur (dec n) (next coll) (conj acc (first coll))))))]
     (take* n coll []))))

; TODO: Higher arities. Needs clojure.core/spread, which needs clojure.core/cons.
(defn apply [f args]
  (native/raw "__value = runtime::apply_to(#{ f }#, #{ args }#);"))

;; Input/output.
(defn print [o]
  (native/raw "__value = jank::runtime::context::print(#{ o }#);"))
(defn println [& args]
  ; TODO: Move println back into here once I sort out two things:
  ; 1. Escaped strings, so I can do the space in between each
  ; 2. The linker errors showing up when using fmt::format_to here
  (native/raw "__value = jank::runtime::context::println(#{ args }#);"))

;; Functions.
(defn ifn? [o]
  (native/raw "__value = make_box
              (
               visit_object
               (
                [=](auto const typed_o) -> native_bool
                {
                 using T = typename decltype(typed_o)::value_type;

                 if constexpr(std::is_base_of_v<behavior::callable, T>)
                 { return true; }
                 else
                 { return false; }
                 },
                #{ o }#
                )
               );"))
(defn fn? [o]
  (native/raw "auto const fn
              (
               #{ o }#->type == object_type::native_function_wrapper
               || #{ o }#->type == object_type::jit_function
               );
              __value = make_box(fn);"))

;; Miscellaneous.
; TODO: This should be a macro.
(def assert)

;; jank.compiler things.
; TODO: Options, following what criterium offers.
(defn benchmark [label fun]
  (native/raw "auto const label_str(expect_object<obj::string>(#{ (str label) }#));
              visit_object
              (
               [=](auto const typed_fun)
               {
                using T = typename decltype(typed_fun)::value_type;

                if constexpr(std::is_base_of_v<behavior::callable, T>)
                {
                 ankerl::nanobench::Config config;
                 //config.mTimeUnitName = TODO
                 config.mOut = &std::cout;

                 /* Ray tracing. */
                 //config.mTimeUnit = std::chrono::milliseconds{ 1 };
                 //config.mMinEpochIterations = 20;
                 //config.mWarmup = 10;

                 /* Smaller things. */
                 config.mTimeUnit = std::chrono::nanoseconds{ 1 };
                 config.mMinEpochIterations = 1000000;
                 config.mWarmup = 1000;

                 ankerl::nanobench::Bench().config(config).run
                 (
                  static_cast<std::string>(label_str->data),
                  [&]
                  {
                   object_ptr res{ typed_fun->call() };
                   ankerl::nanobench::doNotOptimizeAway(res);
                   }
                  );
                 }
                else
                { throw #{ (ex-info :not-callable {:fun fun}) }#; }
                },
               #{ fun }#
               );"))

;; Extra things that usually come from Java.
(defn tan [o]
  (native/raw "__value = make_box(std::tan(runtime::detail::to_real(#{ o }#)));"))

(defn sqrt [o]
  (native/raw "__value = make_box(std::sqrt(runtime::detail::to_real(#{ o }#)));"))

(defn abs [o]
  (native/raw "__value = abs(#{ o }#);"))

(defn pow [x y]
  (native/raw "__value = make_box(std::pow(runtime::detail::to_real(#{ x }#), runtime::detail::to_real(#{ y }#)));"))
(reset-meta! (var pow) {:arities {2 {:supports-unboxed-input? true
                                     :unboxed-output? true}}})
