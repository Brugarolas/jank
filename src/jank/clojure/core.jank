; The layout of this file roughly matches: https://clojure.org/api/cheatsheet

; Namespace management.
(def *ns*)
(def in-ns)

; Exceptions
(def ex-info
  (fn* ex-info [msg map]
    {:error msg
     :data map}))

; Relations.
;; Miscellaneous.
(def true?
  (fn* true? [o]
    (native/raw "__value = runtime::detail::equal(#{ o }#, #{ true }#) ? #{ true }# : #{ false }#")))
(def false?
  (fn* false? [o]
    (native/raw "__value = runtime::detail::equal(#{ o }#, #{ false }#) ? #{ true }# : #{ false }#")))
(def not
  (fn* not [o]
    (native/raw "__value = runtime::detail::equal(#{ o }#, #{ false }#) ? #{ true }# : #{ false }#")))
(def nil?
  (fn* nil? [o]
    (native/raw "__value = (o == obj::nil::nil_const()) ? #{ true }# : #{ false }#")))
(def some?
  (fn* some? [o]
    (native/raw "__value = (o == obj::nil::nil_const()) ? #{ false }# : #{ true }#")))

;; Collections.
(def empty?
  (fn* empty? [o]
    (if (nil? o)
      true
      (native/raw "__value = visit_object
                   (
                     [=](auto const typed_o) -> obj::boolean_ptr
                     {
                       using T = typename decltype(typed_o)::value_type;

                       if constexpr(behavior::seqable<T>)
                       { return make_box(typed_o->seq() == nullptr); }
                       else
                       { throw #{ (ex-info :not-seqable {:o o}) }#; }
                     },
                     #{ o }#
                   );"))))

(def count
  (fn* count [o]
    (if (nil? o)
      0
      (native/raw "__value = make_box(runtime::detail::sequence_length(#{ o }#));"))))

; Lists.
; TODO: Can these be removed from the C++ source?
;(def seq
;  (fn* seq [o]
;    (native/raw "__value = visit_object
;                 (
;                   [=](auto const typed_o) -> object_ptr
;                   {
;                     using T = typename decltype(typed_o)::value_type;
;
;                     if constexpr(std::same_as<T, obj::nil>)
;                     { return typed_o; }
;                     else if constexpr(behavior::seqable<T>)
;                     {
;                       auto const &ret(typed_o->seq());
;                       if(!ret)
;                       { return obj::nil::nil_const(); }
;
;                       return ret;
;                     }
;                     else
;                     { throw #{ (ex-info :not-seqable {:o o}) }#; }
;                   },
;                   #{ o }#
;                 );")))
;(def fresh-seq
;  (fn* fresh-seq [o]
;    (native/raw "__value = visit_object
;                 (
;                   [=](auto const typed_o) -> object_ptr
;                   {
;                     using T = typename decltype(typed_o)::value_type;
;
;                     if constexpr(std::same_as<T, obj::nil>)
;                     { return typed_o; }
;                     else if constexpr(behavior::seqable<T>)
;                     {
;                       auto const &ret(typed_o->seq());
;                       if(!ret)
;                       { return obj::nil::nil_const(); }
;
;                       return ret;
;                     }
;                     else
;                     { throw #{ (ex-info :not-seqable {:o o}) }#; }
;                   },
;                   #{ o }#
;                 );")))
(def first
  (fn* first [o]
    (native/raw "__value = jank::runtime::first(#{ o }#);")))
(def next
  (fn* next [o]
    (native/raw "__value = jank::runtime::next(#{ o }#);")))
(def next-in-place
  (fn* next-in-place [o]
    (native/raw "__value = jank::runtime::next_in_place(#{ o }#);")))
(def nnext
  (fn* nnext [o]
    (next-in-place (next o))))
(def second
  (fn* second [o]
    (first (next o))))
(def rest
  (fn* rest [o]
    (if (nil? o)
      '()
      (native/raw "__value = visit_object
                   (
                     [=](auto const typed_o) -> object_ptr
                     {
                       using T = typename decltype(typed_o)::value_type;

                       if constexpr(behavior::seqable<T>)
                       {
                         auto const seq(typed_o->seq());
                         if(!seq)
                         { return #{ '() }#; }
                         auto const ret(seq->next());
                         if(ret == nullptr)
                         { return #{ '() }#; }
                         return ret;
                       }
                       else
                       { throw #{ (ex-info :not-seqable {:o o}) }#; }
                     },
                     #{ o }#
                   );"))))
(def cons
  (fn* cons [head tail]
    (native/raw "__value = visit_object
                 (
                   [=](auto const typed_tail) -> object_ptr
                   {
                     using T = typename decltype(typed_tail)::value_type;

                     if constexpr(behavior::seqable<T>)
                     { return make_box<jank::runtime::obj::cons>(#{ head }#, typed_tail->seq()); }
                     else
                     { throw #{ (ex-info :invalid-cons-tail {:head head :tail tail}) }#; }
                   },
                   #{ tail }#
                 );")))
(def list
  (fn* list [& items]
    (native/raw "__value = visit_object
                 (
                   [=](auto const typed_items) -> object_ptr
                   {
                     using T = typename decltype(typed_items)::value_type;

                     if constexpr(behavior::seqable<T>)
                     { return jank::runtime::obj::list::create(typed_items); }
                     else
                     { throw #{ (ex-info :invalid-seq {:items items}) }#; }
                   },
                   #{ items }#
                 );")))

;; Vectors.
(def vec
  (fn* vec [coll]
    (native/raw "__value = visit_object
                 (
                   [=](auto const typed_coll) -> object_ptr
                   {
                     using T = typename decltype(typed_coll)::value_type;

                     if constexpr(behavior::seqable<T>)
                     { return jank::runtime::obj::vector::create(typed_coll); }
                     else
                     { throw #{ (ex-info :invalid-seq {:coll coll}) }#; }
                   },
                   #{ coll }#
                 );")))

(def conj)
(def conj
  (fn*
    conj ([]
     [])
    ([coll]
     coll)
    ([coll x]
     (native/raw "__value = jank::runtime::conj(#{ coll }#, #{ x }#);"))
    ([coll x & args]
     (let* [res (conj coll x)]
       (if (empty? args)
         res
         (recur res (first args) (next args)))))))

; Strings.
(def string?
  (fn* string? [o]
    (native/raw "__value = make_box(#{ o }#->type == object_type::string);")))
(def str
  (fn*
    str ([]
     "")
    ([o]
     (native/raw "__value = make_box(runtime::detail::to_string(#{ o }#));"))
    ([o & args]
     (native/raw "__value = visit_object
                 (
                   [=](auto const typed_args) -> object_ptr
                   {
                     using T = typename decltype(typed_args)::value_type;

                     if constexpr(behavior::sequenceable<T>)
                     {
                       fmt::memory_buffer buff;
                       buff.reserve(16);
                       runtime::detail::to_string(#{ o }#, buff);
                       runtime::detail::to_string(typed_args->first(), buff);
                       for(auto it(typed_args->next_in_place()); it != nullptr; it = it->next_in_place())
                       { runtime::detail::to_string(typed_args->first(), buff); }
                       return make_box<obj::string>(native_string{ buff.data(), buff.size() });
                     }
                     else
                     { throw #{ (ex-info :invalid-seq {:args args}) }#; }
                   },
                   #{ args }#
                 );"))))

;; Maps.
(def get
  (fn* get
    ([m k]
     (native/raw "__value = jank::runtime::get(#{ m }#, #{ k }#);"))
    ([m k fallback]
     (native/raw "__value = jank::runtime::get(#{ m }#, #{ k }#, #{ fallback }#);"))))

;; Other.
(def hash
  (fn* hash [o]
    (native/raw "__value = make_box(runtime::detail::to_hash(#{ o }#));")))

(def assoc)
(def assoc
  (fn* assoc
    ([map key val]
     (native/raw "__value = jank::runtime::assoc(#{ map }#, #{ key }#, #{ val }#);"))
    ([map key val & kvs]
     (let* [res (assoc map key val)]
       (if (empty? kvs)
         res
         (do
           (assert (not (empty? (next kvs)))); "assoc expects even number of args after the first"
           (recur res (first kvs) (second kvs) (nnext kvs))))))))

(def reduce*)
(def reduce*
  (fn* reduce*
    ([f coll]
     (let* [s (seq coll)]
       (if s
         (reduce* f (first s) (next s))
         (f))))
    ([f val coll]
     (native/raw "__value = visit_object
                 (
                   [=](auto const typed_coll) -> object_ptr
                   {
                     using T = typename decltype(typed_coll)::value_type;

                     if constexpr(behavior::seqable<T>)
                     {
                       object_ptr res{ #{ val }# };
                       for(auto it(typed_coll->fresh_seq()); it != nullptr; it = it->next_in_place())
                       { res = dynamic_call(#{ f }#, res, it->first()); }
                       return res;
                     }
                     else
                     { throw #{ (ex-info :invalid-seq {:coll coll}) }#; }
                   },
                   #{ coll }#
                 );"))))

(def reverse
  (fn* reverse [coll]
    (reduce* conj () coll)))

; Primitives.
;; Arithmetic.
(def +
  (fn* +
    ([]
     0)
    ([x]
     x)
    ([l r]
     (native/raw "__value = add(#{ l }#, #{ r }#);"))
    ([l r & args]
     (let* [res (native/raw "__value = add(#{ l }#, #{ r }#);")]
       (if (empty? args)
         res
         (recur res (first args) (next args)))))))

(def -)
(def -
  (fn* -
    ([x]
     (- 0 x))
    ([l r]
     (native/raw "__value = sub(#{ l }#, #{ r }#);"))
    ([l r & args]
     (let* [res (native/raw "__value = sub(#{ l }#, #{ r }#);")]
       (if (empty? args)
         res
         (recur res (first args) (next args)))))))

(def *
  (fn* *
    ([]
     1)
    ([x]
     x)
    ([l r]
     (native/raw "__value = mul(#{ l }#, #{ r }#);"))
    ([l r & args]
     (let* [res (native/raw "__value = mul(#{ l }#, #{ r }#);")]
       (if (empty? args)
         res
         (recur res (first args) (next args)))))))

(def /)
(def /
  (fn* _SLASH_
    ([x]
     (/ 1 x))
    ([l r]
     (native/raw "__value = div(#{ l }#, #{ r }#);"))
    ([l r & args]
     (let* [res (native/raw "__value = div(#{ l }#, #{ r }#);")]
       (if (empty? args)
         res
         (recur res (first args) (next args)))))))

(def =
  (fn* =
    ([x]
     true)
    ([l r]
     (native/raw "__value = make_box(runtime::detail::equal(#{ l }#, #{ r }#));"))
    ([l r & args]
     (if (native/raw "__value = make_box(runtime::detail::equal(#{ l }#, #{ r }#));")
       (if (next args)
         (recur r (first args) (next args))
         (native/raw "__value = make_box(runtime::detail::equal(#{ r }#, #{ (first args) }#));"))
       false))))

(def <
  (fn* <
    ([x]
     true)
    ([l r]
     (native/raw "__value = make_box(lt(#{ l }#, #{ r }#));"))
    ([l r & args]
     (if (native/raw "__value = make_box(lt(#{ l }#, #{ r }#));")
       (if (next args)
         (recur r (first args) (next args))
         (native/raw "__value = make_box(lt(#{ r }#, #{ (first args) }#));"))
       false))))

(def <=
  (fn* <=
    ([x]
     true)
    ([l r]
     (native/raw "__value = make_box(lte(#{ l }#, #{ r }#));"))
    ([l r & args]
     (if (native/raw "__value = make_box(lte(#{ l }#, #{ r }#));")
       (if (next args)
         (recur r (first args) (next args))
         (native/raw "__value = make_box(lte(#{ r }#, #{ (first args) }#));"))
       false))))

(def >
  (fn* >
    ([x]
     true)
    ([l r]
     (native/raw "__value = make_box(lt(#{ r }#, #{ l }#));"))
    ([l r & args]
     (if (native/raw "__value = make_box(lt(#{ r }#, #{ l }#));")
       (if (next args)
         (recur r (first args) (next args))
         (native/raw "__value = make_box(lt(#{ (first args) }#, #{ r }#));"))
       false))))

(def >=
  (fn* >=
    ([x]
     true)
    ([l r]
     (native/raw "__value = make_box(lte(#{ r }#, #{ l }#));"))
    ([l r & args]
     (if (native/raw "__value = make_box(lte(#{ r }#, #{ l }#));")
       (if (next args)
         (recur r (first args) (next args))
         (native/raw "__value = make_box(lte(#{ (first args) }#, #{ r }#));"))
       false))))

(def min
  (fn* min
    ([x]
     x)
    ([l r]
     (native/raw "__value = min(#{ l }#, #{ r }#);"))
    ([l r & args]
     (let* [res (native/raw "__value = min(#{ l }#, #{ r }#);")]
       (if (empty? args)
         res
         (recur res (first args) (next args)))))))

(def max
  (fn* max
    ([x]
     x)
    ([l r]
     (native/raw "__value = max(#{ l }#, #{ r }#);"))
    ([l r & args]
     (let* [res (native/raw "__value = max(#{ l }#, #{ r }#);")]
       (if (empty? args)
         res
         (recur res (first args) (next args)))))))

(def inc
  (fn* inc [n]
    (native/raw "__value = inc(#{ n }#);")))
(def dec
  (fn* dec [n]
    (native/raw "__value = dec(#{ n }#);")))

(def pos?
  (fn* pos? [n]
    (native/raw "__value = make_box(is_pos(#{ n }#));")))
(def neg?
  (fn* neg? [n]
    (native/raw "__value = make_box(is_neg(#{ n }#));")))
(def zero?
  (fn* zero? [n]
    (native/raw "__value = make_box(is_zero(#{ n }#));")))

(def rem
  (fn* rem [num div]
    (native/raw "__value = rem(#{ num }#, #{ div }#);")))
(def mod
  (fn* mod [num div]
    (let* [m (rem num div)]
      ; TODO: Could use an or here, if we had it.
      (if (zero? m)
        m
        (if (= (pos? num) (pos? div))
          m
          (+ m div))))))

;; Numbers.
(def integer?
  (fn* integer? [o]
    (native/raw "__value = make_box(#{ o }#->type == object_type::integer)")))
(def float?
  (fn* float? [o]
    (native/raw "__value = make_box(#{ o }#->type == object_type::real)")))
(def boolean?
  (fn* boolean? [o]
    (native/raw "__value = make_box(#{ o }#->type == object_type::boolean)")))
(def number?
  (fn* number? [o]
    (native/raw "__value = make_box
                 (
                   visit_object
                   (
                     [=](auto const typed_o) -> native_bool
                     {
                       using T = typename decltype(typed_o)::value_type;

                       if constexpr(behavior::numberable<T>)
                       { return true; }
                       else
                       { return false; }
                     },
                     #{ o }#
                   )
                 );")))

(def int
  (fn* int [o]
    (native/raw "__value = make_box(to_int(#{ o }#));")))
(def float
  (fn* float [o]
    (native/raw "__value = make_box
                 (
                   visit_object
                   (
                     [=](auto const typed_o) -> native_real
                     {
                       using T = typename decltype(typed_o)::value_type;

                       if constexpr(behavior::numberable<T>)
                       { return typed_o->to_real(); }
                       else
                       { throw #{ (ex-info :not-a-number {:o o}) }#; }
                     },
                     #{ o }#
                   )
                 );")))

(def even?
  (fn* even? [o]
    (native/raw "__value = make_box
                 (
                   visit_object
                   (
                     [=](auto const typed_o) -> native_bool
                     {
                       using T = typename decltype(typed_o)::value_type;

                       if constexpr(std::is_same_v<T, obj::integer>)
                       { return typed_o->data % 2 == 0; }
                       else
                       { throw #{ (ex-info :not-an-integer {:o o}) }#; }
                     },
                     #{ o }#
                   )
                 );")))
(def odd?
  (fn* odd? [o]
    (native/raw "__value = make_box
                 (
                   visit_object
                   (
                     [=](auto const typed_o) -> native_bool
                     {
                       using T = typename decltype(typed_o)::value_type;

                       if constexpr(std::is_same_v<T, obj::integer>)
                       { return typed_o->data % 2 == 1; }
                       else
                       { throw #{ (ex-info :not-an-integer {:o o}) }#; }
                     },
                     #{ o }#
                   )
                 );")))

;; Random.
(def rand)
(def rand
  (fn* rand
    ([]
     (native/raw "__value = make_box(jank::runtime::rand());"))
    ([n]
     (* (rand) n))))

;; Keywords.
(def keyword?
  (fn* keyword? [o]
    (native/raw "__value = make_box(#{ o }#->type == object_type::keyword)")))
(def simple-keyword?
  (fn* simple-keyword? [o]
    (native/raw "__value = make_box
                 (
                   visit_object
                   (
                     [=](auto const typed_o) -> native_bool
                     {
                       using T = typename decltype(typed_o)::value_type;

                       if constexpr(std::is_same_v<T, obj::keyword>)
                       { return typed_o->sym.ns.empty(); }
                       else
                       { return false; }
                     },
                     #{ o }#
                   )
                 );")))
(def qualified-keyword?
  (fn* qualified-keyword? [o]
    (native/raw "__value = make_box
                 (
                   visit_object
                   (
                     [=](auto const typed_o) -> native_bool
                     {
                       using T = typename decltype(typed_o)::value_type;

                       if constexpr(std::is_same_v<T, obj::keyword>)
                       { return !typed_o->sym.ns.empty(); }
                       else
                       { return false; }
                     },
                     #{ o }#
                   )
                 );")))
(def simple-symbol?
  (fn* simple-symbol? [o]
    (native/raw "__value = make_box
                 (
                   visit_object
                   (
                     [=](auto const typed_o) -> native_bool
                     {
                       using T = typename decltype(typed_o)::value_type;

                       if constexpr(std::is_same_v<T, obj::symbol>)
                       { return typed_o->ns.empty(); }
                       else
                       { return false; }
                     },
                     #{ o }#
                   )
                 );")))
(def qualified-symbol?
  (fn* qualified-symbol? [o]
    (native/raw "__value = make_box
                 (
                   visit_object
                   (
                     [=](auto const typed_o) -> native_bool
                     {
                       using T = typename decltype(typed_o)::value_type;

                       if constexpr(std::is_same_v<T, obj::symbol>)
                       { return !typed_o->ns.empty(); }
                       else
                       { return false; }
                     },
                     #{ o }#
                   )
                 );")))
(def symbol?
  (fn* symbol? [o]
    (native/raw "__value = make_box(#{ o }#->type == object_type::symbol)")))

;; Sequences.

(def iterate
  (fn* iterate
    [f x]
    (native/raw "__value = visit_object
                 (
                   [=](auto const typed_f) -> object_ptr
                   {
                     using T = typename decltype(typed_f)::value_type;

                     if constexpr(std::is_base_of_v<behavior::callable, T>)
                     { return make_box<obj::iterator>(typed_f, #{ x }#); }
                     else
                     { throw #{ (ex-info :not-callable {:f f}) }#; }
                   },
                   #{ f }#
                 );")))

(def range
  (fn* range
    ([]
     (iterate inc 0))
    ([end]
     (native/raw "__value = make_box<obj::range>(#{ end }#);"))
    ([start end]
     (native/raw "__value = make_box<obj::range>(#{ start }#, #{ end }#);"))
    ([start end step]
     (native/raw "__value = make_box<obj::range>(#{ start }#, #{ end }#, #{ step }#);"))))

(def take
  (fn* take
    ; TODO: Transducer.
    ([n]
     )
    ([n coll]
     ; TODO: Lazy version once we have lazy-seq.
     (let* [take* (fn* take* [n coll acc]
                    (if (zero? n)
                      acc
                      (if (empty? coll)
                        acc
                        (recur (dec n) (next coll) (conj acc (first coll))))))]
       (take* n coll [])))))

; TODO: Higher arities. Needs clojure.core/spread, which needs clojure.core/cons.
(def apply
  (fn* apply [f args]
    (native/raw "__value = runtime::apply_to(#{ f }#, #{ args }#);")))

;; Input/output.
(def print
  (fn* print [o]
    (native/raw "__value = jank::runtime::context::print(#{ o }#);")))
(def println
  (fn* println [& args]
    ; TODO: Move println back into here once I sort out two things:
    ; 1. Escaped strings, so I can do the space in between each
    ; 2. The linker errors showing up when using fmt::format_to here
    (native/raw "__value = jank::runtime::context::println(#{ args }#);")))

;; Functions.
(def ifn?
  (fn* ifn? [o]
    (native/raw "__value = make_box
                 (
                   visit_object
                   (
                     [=](auto const typed_o) -> native_bool
                     {
                       using T = typename decltype(typed_o)::value_type;

                       if constexpr(std::is_base_of_v<behavior::callable, T>)
                       { return true; }
                       else
                       { return false; }
                     },
                     #{ o }#
                   )
                 );")))
(def fn?
  (fn* fn? [o]
    (native/raw "auto const fn
                (
                  #{ o }#->type == object_type::native_function_wrapper
                  || #{ o }#->type == object_type::jit_function
                );
                __value = make_box(fn);")))

;; Miscellaneous.
; TODO: This should be a macro.
(def assert)

;; Metadata
(def meta
  (fn* meta [o]
    (native/raw "__value = visit_object
                 (
                   [=](auto const typed_o) -> object_ptr
                   {
                     using T = typename decltype(typed_o)::value_type;

                     if constexpr(behavior::metadatable<T>)
                     {
                       if(typed_o->meta.is_none())
                       { return #{ nil }#; }
                       return typed_o->meta.unwrap();
                     }
                     else
                     { return #{ nil }#; }
                   },
                   #{ o }#
                 );")))
(def with-meta
  (fn* with-meta [o m]
    (native/raw "__value = visit_object
                 (
                   [=](auto const typed_o) -> object_ptr
                   {
                     using T = typename decltype(typed_o)::value_type;

                     if constexpr(behavior::metadatable<T>)
                     { return typed_o->with_meta(#{ m }#); }
                     else
                     { throw #{ (ex-info :not-metadatable {:o o}) }#; }
                   },
                   #{ o }#
                 );")))
(def reset-meta!
  (fn* reset-meta! [o m]
    (native/raw "__value = visit_object
                 (
                   [=](auto const typed_o) -> object_ptr
                   {
                     using T = typename decltype(typed_o)::value_type;

                     if constexpr(behavior::metadatable<T>)
                     {
                       auto const meta(behavior::detail::validate_meta(#{ m }#));
                       typed_o->meta = meta;
                       return #{ m }#;
                     }
                     else
                     { throw #{ (ex-info :not-metadatable {:o o}) }#; }
                   },
                   #{ o }#
                 );")))

;; Macros.
(def defn
  (fn* defn [&form &env fn-name fn-args & body]
    (list 'do
          ; TODO: Remove this once fn* supports naming.
          (list 'def fn-name)
          (list 'def fn-name (cons 'fn* (cons fn-name (cons fn-args body)))))))
(reset-meta! (var defn) {:macro true})

(defn defmacro [&form &env fn-name fn-args & body]
  (list 'do
        (list 'def fn-name (cons 'fn* (cons (vec (cons '&form (cons '&env fn-args))) body)))
        (list 'reset-meta! (list 'var fn-name) {:macro true})))
(reset-meta! (var defmacro) {:macro true})

(defmacro when [condition & body]
  (list 'if condition
        (cons 'do body)
        nil))

(defmacro fn [args & body]
  (cons 'fn* (cons args body)))

(defmacro let [args & body]
  (cons 'let* (cons args body)))

(defn macroexpand-1 [form]
  (native/raw "__value = __rt_ctx.macroexpand1(#{ form }#);"))
(defn macroexpand [form]
  (native/raw "__value = __rt_ctx.macroexpand(#{ form }#);"))

;; jank.compiler things.
(def benchmark
  ; TODO: Options, following what criterium offers.
  (fn [label fun]
    (native/raw "auto const label_str(expect_object<obj::string>(#{ (str label) }#));
                 visit_object
                 (
                   [=](auto const typed_fun)
                   {
                     using T = typename decltype(typed_fun)::value_type;

                     if constexpr(std::is_base_of_v<behavior::callable, T>)
                     {
                       ankerl::nanobench::Config config;
                       //config.mTimeUnitName = TODO
                       config.mOut = &std::cout;

                       /* Ray tracing. */
                       //config.mTimeUnit = std::chrono::milliseconds{ 1 };
                       //config.mMinEpochIterations = 20;
                       //config.mWarmup = 10;

                       /* Smaller things. */
                       config.mTimeUnit = std::chrono::nanoseconds{ 1 };
                       config.mMinEpochIterations = 1000000;
                       config.mWarmup = 1000;

                       ankerl::nanobench::Bench().config(config).run
                       (
                         static_cast<std::string>(label_str->data),
                         [&]
                         {
                           object_ptr res{ typed_fun->call() };
                           ankerl::nanobench::doNotOptimizeAway(res);
                         }
                       );
                     }
                     else
                     { throw #{ (ex-info :not-callable {:fun fun}) }#; }
                   },
                   #{ fun }#
                 );")))

;; Extra things that usually come from Java.
(defn tan [o]
  (native/raw "__value = make_box(std::tan(runtime::detail::to_real(#{ o }#)));"))

(defn sqrt [o]
  (native/raw "__value = make_box(std::sqrt(runtime::detail::to_real(#{ o }#)));"))

(defn abs [o]
  (native/raw "__value = abs(#{ o }#);"))

(defn pow [x y]
  (native/raw "__value = make_box(std::pow(runtime::detail::to_real(#{ x }#), runtime::detail::to_real(#{ y }#)));"))
